#!/usr/bin/env python

# =============================================================================
# Copyright (C) 2016 Miriam Cabero Mueller, Collin Capano
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
# =============================================================================

import itertools
import logging
import sys
import numpy
import matplotlib
from matplotlib import patches, use
import pycbc
from pycbc.results.plot import add_style_opt_to_parser, set_style_from_cli
from pycbc.results import metadata
from pycbc.io import FieldArray
from pycbc import conversions
from pycbc.workflow import WorkflowConfigParser
from pycbc.inference import option_utils, io
from pycbc.distributions.utils import prior_from_config
from pycbc.results.scatter_histograms import create_multidim_plot

# Set matplotlib to use Agg backend (non-interactive)
use('agg')

# Command-line argument parsing setup
parser = io.ResultsArgumentParser()
pycbc.add_common_pycbc_options(parser)

# Program-specific arguments
parser.add_argument("--output-file", type=str, required=True,
                    help="Output plot path.")
parser.add_argument("--plot-prior", nargs="+", type=str,
                    help="Plot the prior on the 1D marginal plots using the "
                         "given config file(s).")
parser.add_argument("--prior-nsamples", type=int, default=10000,
                    help="Number of samples to use for plotting the prior. Default is 10000.")
parser.add_argument("--colors-multi-run", nargs="+", type=str,
                    help="For multiple runs, provide colours to be used for successively. Default is to use the successive colours specified in matplotlib color cycle.")
parser.add_argument("--fill-hist", action="store_true", default=False,
                    help="Fill the 1D marginalized histograms.")
parser.add_argument("--hist-color", help="Color for histogram outline. Default is black.")
parser.add_argument("--hist-fill-color", default='gray',
                    help="Color for filled histograms. Default is gray.")
option_utils.add_plot_posterior_option_group(parser)  # Scatter, density, etc.
option_utils.add_scatter_option_group(parser)
option_utils.add_density_option_group(parser)
parser.add_argument("--plot-maxl", action="store_true", default=False,
                    help="Put a marker on the 2D marginal where the maxL point is.")
parser.add_argument('--legend-location', default='upper right',
                    help='Location for the legend (if multiple files are provided). Default is "upper right".')
parser.add_argument('--dpi', type=int, default=200,
                    help="Set the DPI of the plot. Default is 200.")
add_style_opt_to_parser(parser)

# Parse command line arguments
opts = parser.parse_args()
set_style_from_cli(opts)  # Set style based on CLI options

# Additional KDE arguments
kdeargs = {'max_kde_samples': opts.max_kde_samples}
if opts.kde_args is not None:
    for opt in opts.kde_args:
        opt, val = opt.split(':')
        try:
            val = float(val)
            if val % 1 == 0:
                val = int(val)
        except TypeError:
            pass
        kdeargs[opt] = val

# Logging setup
pycbc.init_logging(opts.verbose)

# Load the samples
fps, parameters, labels, samples = io.results_from_cli(opts)

# Filter out loglikelihood if needed
if opts.plot_maxl:
    add_logl = 'loglikelihood' not in opts.parameters
    if add_logl:
        opts.parameters.append('loglikelihood')
else:
    add_logl = False

# Check if z-argument is set and handle appropriately
if opts.z_arg is not None:
    logging.info("Getting samples for colorbar")
    z_arg = 'loglikelihood' if opts.z_arg == 'snr' else opts.z_arg
    zlbl = opts.z_arg_labels.get(opts.z_arg, 'Default Label')  # Use default if not found
    zvals = []
    for fp in fps:
        zsamples = fp.samples_from_cli(opts, parameters=z_arg)
        if opts.z_arg == 'snr':
            loglr = zsamples[z_arg] - zsamples.lognl
            zsamples[z_arg] = conversions.snr_from_loglr(loglr)
        zvals.append(zsamples[z_arg])
else:
    zvals = []  # Default to empty list to avoid NameError
    zlbl = 'No Z-Argument'  # Provide a default label if no z-arg

# Load the color cycle for plotting
color_cycle = [c['color'] for c in matplotlib.rcParams['axes.prop_cycle']]
colors = itertools.cycle(opts.colors_multi_run) if opts.colors_multi_run else itertools.cycle(color_cycle)

# Prepare for plotting
logging.info("Plotting")
hist_colors = []

# Loop over each sample for plotting
for (i, s) in enumerate(samples):
    # Initialize the figure and axis dictionary for the first iteration
    if i == 0:
        fig, axis_dict = None, None

    # Set line color for histograms
    linecolor = opts.hist_color if opts.hist_color else next(colors)

    # Set histogram and contour colors
    hist_color = opts.hist_color if opts.hist_color else ('white' if opts.mpl_style == 'dark_background' else 'black')
    fill_color = opts.hist_fill_color if opts.fill_hist else None
    contour_color = hist_color if not opts.contour_color else opts.contour_color

    # Plot the multidimensional posterior
    fig, axis_dict = create_multidim_plot(
        parameters, s, labels=labels, fig=fig, axis_dict=axis_dict,
        plot_marginal=opts.plot_marginal,
        plot_marginal_lines=not opts.no_marginal_lines,
        plot_maxl=opts.plot_maxl,
        marginal_percentiles=opts.marginal_percentiles,
        plot_scatter=opts.plot_scatter,
        zvals=zvals[i] if zvals is not None else None,
        show_colorbar=opts.z_arg is not None,
        cbar_label=zlbl,
        scatter_cmap=opts.scatter_cmap,
        plot_density=opts.plot_density,
        plot_contours=opts.plot_contours,
        contour_percentiles=opts.contour_percentiles,
        density_cmap=opts.density_cmap,
        contour_color=contour_color,
        contour_linestyles=opts.contour_linestyles,
        label_contours=not opts.no_contour_labels,
        hist_color=hist_color,
        line_color=linecolor,
        fill_color=fill_color,
        use_kombine=opts.use_kombine_kde,
        kdeargs=kdeargs,
        mins=mins, maxs=maxs,
        expected_parameters=expected_parameters,
        expected_parameters_color=opts.expected_parameters_color)

# Optionally plot the prior
if opts.plot_prior:
    if len(opts.input_file) > 1:
        hist_color = next(colors)
    fig, axis_dict = create_multidim_plot(
        parameters, prior_samples, fig=fig, axis_dict=axis_dict,
        labels=labels, plot_marginal=True, marginal_percentiles=[],
        plot_scatter=False, plot_density=False, plot_contours=False,
        fill_color=None,
        marginal_title=False, marginal_linestyle=':',
        hist_color=hist_color,
        mins=mins, maxs=maxs)

# Add legend for multiple input files
if len(opts.input_file) > 1:
    handles = [patches.Patch(color=color, label=label) for color, label in zip(hist_colors, opts.input_file)]
    addto = axis_dict[parameters[0], parameters[1]][0] if len(parameters) == 2 else fig
    addto.legend(loc=opts.legend_location, handles=handles)

# Set DPI and save the figure
fig.set_dpi(opts.dpi)
metadata.save_fig_with_metadata(
    fig, opts.output_file,
    cmd=" ".join(sys.argv),
    title="Posteriors",
    caption="Posterior probability density functions.",
    fig_kwds={'bbox_inches': 'tight'}
)

# Finish
logging.info("Done")
